import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt
import random

class Car:
    """A car agent with speed and position along edges."""
    def __init__(self, start, destination):
        self.current_location = start  
        self.destination = destination
        self.path = []
        self.parked = False
        
        # Track position and speed
        self.current_edge = None  # (u, v) tuple or None if at node
        self.position_on_edge = 0.0  # Distance traveled along current edge (meters)
        self.speed = 5.0  # Current speed in meters per second

class TrafficNetwork:
    """Traffic simulation with density-based congestion."""

    def __init__(self, graph=None, cars=[]):
        self.graph = graph
        self.cars = cars

    def load_road_network(self, address=None, dist=200, network_type="drive"):
        self.graph = ox.graph_from_address(
            address,
            dist=dist,
            network_type=network_type,
        )
        return self.graph
    
    def edge_car_counts(self):
        """Count how many cars are currently on each edge."""
        counts = {(u, v, 0): 0 for u, v, _ in self.graph.edges(keys=True)}
        for car in self.cars:
            if car.current_edge:
                u, v = car.current_edge
                counts[(u, v, 0)] += 1
        return counts

    def add_travel_time_attribute(self, default_speed=30):
        for u, v, k, data in self.graph.edges(data=True, keys=True):
            speed = data.get("maxspeed", default_speed)
            if isinstance(speed, list):
                speed = speed[0]
            if isinstance(speed, str):
                speed = speed.split(" ")[0]
            data["travel_time"] = data["length"] / (float(speed) * 1000 / 60)
        return self.graph   
    
    def compute_edge_density(self, edge):
        """Calculate traffic density on an edge (0.0 = empty, 1.0+ = congested)."""
        u, v = edge
        edge_length = self.graph[u][v][0]['length']  # meters
        edge_capacity = edge_length / 5  # Assume 5 meters per car
        
        # Count cars on this edge
        cars_on_edge = sum(1 for car in self.cars if car.current_edge == edge)
        
        return cars_on_edge / edge_capacity if edge_capacity > 0 else 0
    
    def update_car_speed(self, car, max_speed=5.0):
        """Adjust car speed based on traffic density."""
        if car.current_edge is None:
            car.speed = max_speed
            return
        
        density = self.compute_edge_density(car.current_edge)
        
        # Speed decreases with density
        if density < 0.2:
            car.speed = max_speed  # Free flow
        elif density < 0.8:
            car.speed = max_speed * (1 - 0.5*density)  # Gradual slowdown
        else:
            car.speed = max_speed * 0.2  # Heavy traffic, but still moving
    
    def move_cars(self):
        """Advance all cars by one simulation step (simultaneous update)."""
        
        # PHASE 1: Update speeds for all cars based on current density
        for car in self.cars:
            if car.parked:
                continue
            self.update_car_speed(car)
        
        # PHASE 2: Move all cars based on their speeds
        for car in self.cars:
            if car.parked:
                continue

            # Check if car has reached its destination
            if car.current_location == car.destination:
                car.parked = True
                continue

            # Compute path if needed
            if not car.path:
                try:
                    car.path = nx.shortest_path(
                        self.graph,
                        car.current_location,
                        car.destination,
                        weight="travel_time",
                    )
                    # Remove current location from path
                    if car.path and car.path[0] == car.current_location:
                        car.path.pop(0)
                except nx.NetworkXNoPath:
                    car.parked = True
                    continue
            
            if not car.path:
                car.parked = True
                continue

            # If at a node, start moving to next node
            if car.current_edge is None:
                next_node = car.path[0]
                car.current_edge = (car.current_location, next_node)
                car.position_on_edge = 0.0
            
            # Move along current edge
            edge_length = self.graph[car.current_edge[0]][car.current_edge[1]][0]['length']
            car.position_on_edge += car.speed  # Move forward
            
            # Check if reached end of edge
            if car.position_on_edge >= edge_length:
                # Arrived at next node
                car.current_location = car.current_edge[1]
                car.path.pop(0)  # Remove this node from path
                car.current_edge = None
                car.position_on_edge = 0.0

    def plot_network(self):
        """Plot the raw road network using OSMnx defaults."""
        fig, ax = ox.plot_graph(self.graph, figsize=(10, 10))
        return fig, ax

    def simulate_traffic(self, num_cars=100, num_steps=10):
        """Run traffic simulation."""
        # Create cars with random starts and destinations
        nodes = list(self.graph.nodes())
        self.cars = [Car(random.choice(nodes), random.choice(nodes)) for _ in range(num_cars)]

        for step in range(num_steps):
            self.move_cars()

            # Print stats
            print(f"\nStep {step + 1}:")
            parked = sum(1 for car in self.cars if car.parked)
            moving = len(self.cars) - parked
            print(f"  Moving: {moving}, Parked: {parked}")
            
            # Show average speed
            avg_speed = sum(car.speed for car in self.cars if not car.parked) / max(moving, 1)
            print(f"  Average speed: {avg_speed:.2f} m/s")

        return self.cars

    def plot_network_with_traffic(self):
        """Plot network with edges colored by traffic density."""
        edge_colors = []
        edge_widths = []

        counts = self.edge_car_counts()
        max_count = max(counts.values()) if counts.values() else 1

        for u, v, _ in self.graph.edges(keys=True):
            count = counts.get((u, v, 0), 0)
            edge_colors.append(plt.cm.Reds(count / max_count if max_count > 0 else 0))
            edge_widths.append(1 + count)

        fig, ax = ox.plot_graph(
            self.graph, 
            figsize=(10, 10), 
            edge_color=edge_colors, 
            edge_linewidth=edge_widths
        )
        return fig, ax



network = TrafficNetwork()
network.load_road_network('Market St, San Francisco, CA', dist=2000,network_type='drive')
network.add_travel_time_attribute()

# Simulation
network.simulate_traffic(num_cars=5000, num_steps=20)

# Visualize
network.plot_network_with_traffic()
plt.show()

